name: Postman Sync for Repos

on:
  # Trigger on branch creation and push to feature/bugfix/hotfix branches
  # Also trigger on main for initial workspace setup
  push:
    branches:
      - 'main'
      - 'master'
      - 'feature/**'
      - 'bugfix/**'
      - 'hotfix/**'
  
  create:
    # Triggered when a branch or tag is created
  
  # Trigger on pull request merge for fork cleanup
  pull_request:
    types: [closed]
    
  # Manual trigger for workspace/collection creation
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - create-workspace
          - create-collection
      resource_name:
        description: 'Name of the workspace or collection'
        required: true
        type: string
      workspace_id:
        description: 'Workspace ID (for collection creation)'
        required: false
        type: string
      description:
        description: 'Description for the resource'
        required: false
        type: string
        default: ''

jobs:
  postman-sync:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: write  # Required for gh variable set
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
    
    - name: Determine action type
      id: determine_action
      run: |
        # Check what triggered the workflow
        # Extract org/team and repo name
        REPO="${{ github.repository }}"
        ORG_OR_USER=$(echo $REPO | cut -d'/' -f1)
        REPO_NAME=$(echo $REPO | cut -d'/' -f2)
        
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "action_type=${{ inputs.action }}" >> $GITHUB_OUTPUT
          if [ "${{ inputs.action }}" = "create-workspace" ]; then
            # Workspace name format: "[org] repo-name"
            echo "resource_name=[${ORG_OR_USER}] ${REPO_NAME}" >> $GITHUB_OUTPUT
          else
            echo "resource_name=${{ inputs.resource_name }}" >> $GITHUB_OUTPUT
          fi
        elif [ "${{ github.event_name }}" = "pull_request" ] && [ "${{ github.event.pull_request.merged }}" = "true" ]; then
          # PR was merged - cleanup fork
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          if [[ "$BRANCH_NAME" =~ ^(feature|bugfix|hotfix)/ ]]; then
            echo "action_type=merge-cleanup" >> $GITHUB_OUTPUT
            # Collection name format: "[org] repo-name #branch-type"
            BRANCH_TYPE=$(echo $BRANCH_NAME | sed 's|/.*||')
            BRANCH_DETAIL=$(echo $BRANCH_NAME | sed 's|^[^/]*/||')
            echo "resource_name=[${ORG_OR_USER}] ${REPO_NAME} #${BRANCH_TYPE}-${BRANCH_DETAIL}" >> $GITHUB_OUTPUT
          else
            echo "action_type=skip" >> $GITHUB_OUTPUT
          fi
        elif [ "${{ github.event_name }}" = "create" ] && [ "${{ github.ref_type }}" = "branch" ]; then
          # Branch was created
          BRANCH_NAME="${{ github.ref_name }}"
          if [[ "$BRANCH_NAME" =~ ^(feature|bugfix|hotfix)/ ]]; then
            echo "action_type=create-collection" >> $GITHUB_OUTPUT
            # Collection name format: "[org] repo-name #branch-type"
            BRANCH_TYPE=$(echo $BRANCH_NAME | sed 's|/.*||')
            BRANCH_DETAIL=$(echo $BRANCH_NAME | sed 's|^[^/]*/||')
            echo "resource_name=[${ORG_OR_USER}] ${REPO_NAME} #${BRANCH_TYPE}-${BRANCH_DETAIL}" >> $GITHUB_OUTPUT
          else
            echo "action_type=skip" >> $GITHUB_OUTPUT
          fi
        elif [ "${{ github.event_name }}" = "push" ]; then
          BRANCH_NAME="${{ github.ref_name }}"
          if [[ "$BRANCH_NAME" =~ ^(main|master)$ ]]; then
            # Push to main/master - ensure workspace exists
            echo "action_type=ensure-workspace" >> $GITHUB_OUTPUT
            echo "resource_name=[${ORG_OR_USER}] ${REPO_NAME}" >> $GITHUB_OUTPUT
          else
            # Push to feature/bugfix/hotfix branch
            echo "action_type=create-collection" >> $GITHUB_OUTPUT
            # Collection name format: "[org] repo-name #branch-type"
            BRANCH_TYPE=$(echo $BRANCH_NAME | sed 's|/.*||')
            BRANCH_DETAIL=$(echo $BRANCH_NAME | sed 's|^[^/]*/||')
            echo "resource_name=[${ORG_OR_USER}] ${REPO_NAME} #${BRANCH_TYPE}-${BRANCH_DETAIL}" >> $GITHUB_OUTPUT
          fi
        else
          echo "action_type=skip" >> $GITHUB_OUTPUT
        fi
    
    - name: Get User Email
      if: steps.determine_action.outputs.action_type != 'skip'
      id: get_email
      run: |
        # GitHub Enterprise provides sender email in the event context
        USER_EMAIL="${{ github.event.sender.email }}"
        
        # Fallback for specific event types if sender.email is not available
        if [ -z "$USER_EMAIL" ]; then
          if [ "${{ github.event_name }}" = "push" ]; then
            USER_EMAIL="${{ github.event.head_commit.author.email }}"
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            USER_EMAIL="${{ github.event.pull_request.user.email }}"
          fi
        fi
        
        echo "User: ${{ github.actor }}"
        echo "Email: $USER_EMAIL"
        echo "user_email=$USER_EMAIL" >> $GITHUB_OUTPUT

    - name: Validate User Access
      if: steps.determine_action.outputs.action_type != 'skip'
      id: validate_user
      env:
        POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
      run: |
        # Validate user against Postman team membership
        USER="${{ github.actor }}"
        USER_EMAIL="${{ steps.get_email.outputs.user_email }}"
        ALLOW_ALL="${{ vars.POSTMAN_ALLOW_ALL_USERS || 'false' }}"

        echo "Validating user: $USER ($USER_EMAIL)"

        if [ "$ALLOW_ALL" = "true" ]; then
          echo "User validation: Allowing $USER (POSTMAN_ALLOW_ALL_USERS=true)"
          echo "user_authorized=true" >> $GITHUB_OUTPUT
        elif [ -n "$USER_EMAIL" ]; then
          echo "Checking if $USER_EMAIL is in Postman team..."
          node scripts/create-postman-resources.js validate-user "$USER_EMAIL"

          if [ $? -eq 0 ]; then
            echo "User $USER_EMAIL is authorized (found in Postman team)"
            echo "user_authorized=true" >> $GITHUB_OUTPUT
          else
            echo "User $USER_EMAIL not found in Postman team"
            echo "user_authorized=false" >> $GITHUB_OUTPUT
            echo "validation_message=User $USER ($USER_EMAIL) not found in Postman team" >> $GITHUB_OUTPUT
          fi
        else
          echo "Could not resolve email for user $USER"
          echo "user_authorized=false" >> $GITHUB_OUTPUT
          echo "validation_message=Could not resolve email for user $USER" >> $GITHUB_OUTPUT
        fi

    - name: User Authorization Warning
      if: steps.determine_action.outputs.action_type != 'skip' && steps.validate_user.outputs.user_authorized == 'false'
      run: |
        echo "## WARNING: Postman Sync Skipped"
        echo ""
        echo "${{ steps.validate_user.outputs.validation_message }}"
        echo ""
        echo "The workflow will continue without creating Postman resources."
        echo ""
        echo "To enable Postman sync:"
        echo "1. Add user to Postman team for automatic sync, or"
        echo "2. Set repository variable POSTMAN_ALLOW_ALL_USERS=true to bypass validation"
        echo ""
        echo "Proceeding with workflow..."

    - name: Create Postman Workspace
      if: steps.determine_action.outputs.action_type == 'create-workspace' && steps.validate_user.outputs.user_authorized == 'true'
      id: create_workspace
      env:
        POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
        GITHUB_OUTPUT: ${{ github.output }}
      run: |
        # Create workspace (automatically creates #main collection)
        node scripts/create-postman-resources.js workspace \
          "${{ steps.determine_action.outputs.resource_name }}"

    - name: Store Workspace and Master Collection IDs
      if: steps.create_workspace.outputs.workspace_id
      run: |
        # Store workspace ID and master collection ID as repository variables for future use
        gh variable set POSTMAN_WORKSPACE_ID \
          --body "${{ steps.create_workspace.outputs.workspace_id }}"
        gh variable set POSTMAN_MASTER_COLLECTION_ID \
          --body "${{ steps.create_workspace.outputs.master_collection_id }}"

        echo "Workspace ID stored as repository variable: POSTMAN_WORKSPACE_ID"
        echo "Master Collection ID stored as repository variable: POSTMAN_MASTER_COLLECTION_ID"
        echo "Future collection creation will use these IDs for efficient forking"

    - name: Ensure Workspace Exists
      if: steps.determine_action.outputs.action_type == 'ensure-workspace' && steps.validate_user.outputs.user_authorized == 'true'
      id: ensure_workspace
      env:
        POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
        GITHUB_OUTPUT: ${{ github.output }}
      run: |
        WORKSPACE_ID="${{ vars.POSTMAN_WORKSPACE_ID }}"
        
        if [ -z "$WORKSPACE_ID" ]; then
          echo "No workspace found for this repository - creating workspace + master collection"
          
          # Create workspace (automatically creates #main collection)
          node scripts/create-postman-resources.js workspace \
            "${{ steps.determine_action.outputs.resource_name }}"
          
          # Store the workspace ID and master collection ID from script output
          WORKSPACE_ID=$(grep 'workspace_id=' $GITHUB_OUTPUT | tail -1 | cut -d'=' -f2)
          MASTER_COLLECTION_ID=$(grep 'master_collection_id=' $GITHUB_OUTPUT | tail -1 | cut -d'=' -f2)

          # Set as repository variables for future use
          gh variable set POSTMAN_WORKSPACE_ID --body "$WORKSPACE_ID"
          gh variable set POSTMAN_MASTER_COLLECTION_ID --body "$MASTER_COLLECTION_ID"

          echo "Created workspace: ${{ steps.determine_action.outputs.resource_name }} ($WORKSPACE_ID)"
          echo "Created master collection: ${{ steps.determine_action.outputs.resource_name }} #main ($MASTER_COLLECTION_ID)"
        else
          echo "Workspace already exists: $WORKSPACE_ID"
          echo "No action needed - workspace and master collection already set up"
        fi
    
    - name: Auto-Create Workspace If Needed
      if: steps.determine_action.outputs.action_type == 'create-collection' && steps.validate_user.outputs.user_authorized == 'true'
      id: auto_workspace
      env:
        POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
        GITHUB_OUTPUT: ${{ github.output }}
      run: |
        WORKSPACE_ID="${{ inputs.workspace_id || vars.POSTMAN_WORKSPACE_ID }}"
        
        if [ -z "$WORKSPACE_ID" ]; then
          echo "No workspace found - auto-creating workspace for this repository"
          
          # Extract repo info for workspace name
          REPO="${{ github.repository }}"
          ORG_OR_USER=$(echo $REPO | cut -d'/' -f1)
          REPO_NAME=$(echo $REPO | cut -d'/' -f2)
          WORKSPACE_NAME="[${ORG_OR_USER}] ${REPO_NAME}"
          
          # Create workspace
          node scripts/create-postman-resources.js workspace "$WORKSPACE_NAME"
          
          # Store the workspace ID and master collection ID
          WORKSPACE_ID=$(grep 'workspace_id=' $GITHUB_OUTPUT | cut -d'=' -f2)
          MASTER_COLLECTION_ID=$(grep 'master_collection_id=' $GITHUB_OUTPUT | cut -d'=' -f2)

          # Set as repository variables for future use
          gh variable set POSTMAN_WORKSPACE_ID --body "$WORKSPACE_ID"
          gh variable set POSTMAN_MASTER_COLLECTION_ID --body "$MASTER_COLLECTION_ID"

          echo "Auto-created workspace: $WORKSPACE_NAME ($WORKSPACE_ID)"
          echo "Auto-created master collection ID: $MASTER_COLLECTION_ID"
          echo "workspace_id=$WORKSPACE_ID" >> $GITHUB_OUTPUT
          echo "master_collection_id=$MASTER_COLLECTION_ID" >> $GITHUB_OUTPUT
        else
          echo "Using existing workspace: $WORKSPACE_ID"
          echo "workspace_id=$WORKSPACE_ID" >> $GITHUB_OUTPUT
        fi

    - name: Create Postman Collection
      if: steps.determine_action.outputs.action_type == 'create-collection' && steps.validate_user.outputs.user_authorized == 'true'
      env:
        POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
        GITHUB_OUTPUT: ${{ github.output }}
      run: |
        # Smart collection creation - automatically forks if it's a branch
        # Pass master collection ID for efficient forking (if available)
        MASTER_COLLECTION_ID="${{ steps.auto_workspace.outputs.master_collection_id || vars.POSTMAN_MASTER_COLLECTION_ID || '' }}"

        if [ -n "$MASTER_COLLECTION_ID" ]; then
          echo "Using master collection ID for efficient forking: $MASTER_COLLECTION_ID"
          node scripts/create-postman-resources.js collection \
            "${{ steps.determine_action.outputs.resource_name }}" \
            "${{ steps.auto_workspace.outputs.workspace_id }}" \
            "$MASTER_COLLECTION_ID"
        else
          echo "No master collection ID available, will search for it"
          node scripts/create-postman-resources.js collection \
            "${{ steps.determine_action.outputs.resource_name }}" \
            "${{ steps.auto_workspace.outputs.workspace_id }}"
        fi
    
    - name: Merge and Cleanup Fork
      if: steps.determine_action.outputs.action_type == 'merge-cleanup' && steps.validate_user.outputs.user_authorized == 'true'
      env:
        POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
        POSTMAN_WORKSPACE_ID: ${{ vars.POSTMAN_WORKSPACE_ID }}
      run: |
        # Find and delete the fork collection after PR merge
        COLLECTION_NAME="${{ steps.determine_action.outputs.resource_name }}"
        
        echo "Looking for fork collection: $COLLECTION_NAME"
        
        # Get all collections in the workspace
        WORKSPACE_ID="${{ env.POSTMAN_WORKSPACE_ID }}"
        
        if [ -z "$WORKSPACE_ID" ]; then
          echo "No workspace ID found - cannot cleanup fork"
          exit 0
        fi
        
        # Get workspace details and find the collection
        response=$(curl -s -X GET \
          "https://api.getpostman.com/workspaces/${WORKSPACE_ID}" \
          -H "X-API-Key: ${{ env.POSTMAN_API_KEY }}")
        
        # Extract collection matching the fork name
        collection_id=$(echo "$response" | python3 -c "
        import sys, json
        data = json.load(sys.stdin)
        collections = data.get('workspace', {}).get('collections', [])
        fork_name = '$COLLECTION_NAME'
        for col in collections:
            if col.get('name') == fork_name:
                print(col.get('id', ''))
                break
        ")
        
        if [ -n "$collection_id" ]; then
          echo "Found fork collection: $collection_id"
          
          # Delete the fork collection
          curl -X DELETE \
            "https://api.getpostman.com/collections/${collection_id}" \
            -H "X-API-Key: ${{ env.POSTMAN_API_KEY }}"
          
          echo "Fork collection deleted after successful merge"
        else
          echo "Fork collection not found (may have been manually deleted)"
        fi
        
        echo "Note: In production, consider implementing full PR-to-Postman sync for the main collection"
    
    - name: Create Summary
      if: steps.determine_action.outputs.action_type != 'skip'
      run: |
        echo "## Postman Sync Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Action:** ${{ steps.determine_action.outputs.action_type }}" >> $GITHUB_STEP_SUMMARY
        echo "**Resource:** ${{ steps.determine_action.outputs.resource_name }}" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ steps.validate_user.outputs.user_authorized }}" = "false" ]; then
          echo "**Status:** SKIPPED - User not in Postman team" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Authorization Details" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.validate_user.outputs.validation_message }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "To enable automatic Postman sync:" >> $GITHUB_STEP_SUMMARY
          echo "1. Add user to Postman team, or" >> $GITHUB_STEP_SUMMARY
          echo "2. Set \`POSTMAN_ALLOW_ALL_USERS=true\` repository variable" >> $GITHUB_STEP_SUMMARY
        else
          echo "**Status:** SUCCESS - ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.determine_action.outputs.action_type }}" = "create-workspace" ] && [ -n "${{ steps.create_workspace.outputs.workspace_id }}" ]; then
            echo "**Workspace ID:** ${{ steps.create_workspace.outputs.workspace_id }}" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.determine_action.outputs.action_type }}" = "ensure-workspace" ]; then
            echo "**Workspace Setup:** Complete - Ready for branch collections" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.determine_action.outputs.action_type }}" = "create-collection" ] && [ -n "${{ steps.create_collection.outputs.collection_id }}" ]; then
            echo "**Collection ID:** ${{ steps.create_collection.outputs.collection_id }}" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.determine_action.outputs.action_type }}" = "merge-cleanup" ]; then
            echo "**Fork Cleanup:** Collection deleted after merge" >> $GITHUB_STEP_SUMMARY
          fi
        fi