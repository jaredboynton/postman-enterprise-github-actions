name: Postman Sync for Organizations

on:
  workflow_call:
    inputs:
      action:
        description: 'Action to perform (create-workspace or create-collection)'
        type: string
        required: false
      resource_name:
        description: 'Name of the workspace or collection'
        type: string
        required: false
    secrets:
      POSTMAN_API_KEY:
        required: true
        description: 'Postman API Key (set at org level)'
      ORG_DISPATCH_TOKEN:
        required: false
        description: 'GitHub PAT with repo scope for automated variable storage (optional)'

jobs:
  postman-sync:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: write  # Required for gh variable set in calling repo

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'

    - name: Download Postman Scripts
      run: |
        # Download the script from the postman-cs scaffolding repo
        mkdir -p scripts

        # Download with error handling
        echo "Downloading Postman resource creation script..."
        if ! curl -fsSL -o scripts/create-postman-resources.js \
          https://raw.githubusercontent.com/postman-cs/postman-scaffolding/master/scripts/create-postman-resources.js; then
          echo "ERROR: Failed to download script from postman-cs/postman-scaffolding"
          echo "Please ensure the repository is accessible"
          exit 1
        fi

        # Verify the script was downloaded
        if [ ! -f scripts/create-postman-resources.js ]; then
          echo "ERROR: Script download appeared successful but file not found"
          exit 1
        fi

        echo "Script downloaded successfully"

    - name: Determine action type
      id: determine_action
      run: |
        # Check what triggered the workflow
        # Extract org/team and repo name
        REPO="${{ github.repository }}"
        ORG_OR_USER=$(echo $REPO | cut -d'/' -f1)
        REPO_NAME=$(echo $REPO | cut -d'/' -f2)

        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "action_type=${{ inputs.action }}" >> $GITHUB_OUTPUT
          if [ "${{ inputs.action }}" = "create-workspace" ]; then
            # Workspace name format: "[org] repo-name"
            echo "resource_name=[${ORG_OR_USER}] ${REPO_NAME}" >> $GITHUB_OUTPUT
          else
            echo "resource_name=${{ inputs.resource_name }}" >> $GITHUB_OUTPUT
          fi
        elif [ "${{ github.event_name }}" = "pull_request" ] && [ "${{ github.event.pull_request.merged }}" = "true" ]; then
          # PR was merged - cleanup fork
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          if [[ "$BRANCH_NAME" =~ ^(feature|bugfix|hotfix)/ ]]; then
            echo "action_type=merge-cleanup" >> $GITHUB_OUTPUT
            # Collection name format: "[org] repo-name #branch-type"
            BRANCH_TYPE=$(echo $BRANCH_NAME | sed 's|/.*||')
            BRANCH_DETAIL=$(echo $BRANCH_NAME | sed 's|^[^/]*/||')
            echo "resource_name=[${ORG_OR_USER}] ${REPO_NAME} #${BRANCH_TYPE}-${BRANCH_DETAIL}" >> $GITHUB_OUTPUT
          else
            echo "action_type=skip" >> $GITHUB_OUTPUT
          fi
        elif [ "${{ github.event_name }}" = "create" ] && [ "${{ github.ref_type }}" = "branch" ]; then
          # Branch was created
          BRANCH_NAME="${{ github.ref_name }}"
          if [[ "$BRANCH_NAME" =~ ^(feature|bugfix|hotfix)/ ]]; then
            echo "action_type=create-collection" >> $GITHUB_OUTPUT
            # Collection name format: "[org] repo-name #branch-type"
            BRANCH_TYPE=$(echo $BRANCH_NAME | sed 's|/.*||')
            BRANCH_DETAIL=$(echo $BRANCH_NAME | sed 's|^[^/]*/||')
            echo "resource_name=[${ORG_OR_USER}] ${REPO_NAME} #${BRANCH_TYPE}-${BRANCH_DETAIL}" >> $GITHUB_OUTPUT
          else
            echo "action_type=skip" >> $GITHUB_OUTPUT
          fi
        elif [ "${{ github.event_name }}" = "push" ]; then
          BRANCH_NAME="${{ github.ref_name }}"
          if [[ "$BRANCH_NAME" =~ ^(main|master)$ ]]; then
            # Push to main/master - ensure workspace exists
            echo "action_type=ensure-workspace" >> $GITHUB_OUTPUT
            echo "resource_name=[${ORG_OR_USER}] ${REPO_NAME}" >> $GITHUB_OUTPUT
          else
            # Push to feature/bugfix/hotfix branch
            echo "action_type=create-collection" >> $GITHUB_OUTPUT
            # Collection name format: "[org] repo-name #branch-type"
            BRANCH_TYPE=$(echo $BRANCH_NAME | sed 's|/.*||')
            BRANCH_DETAIL=$(echo $BRANCH_NAME | sed 's|^[^/]*/||')
            echo "resource_name=[${ORG_OR_USER}] ${REPO_NAME} #${BRANCH_TYPE}-${BRANCH_DETAIL}" >> $GITHUB_OUTPUT
          fi
        else
          echo "action_type=skip" >> $GITHUB_OUTPUT
        fi

    - name: Get User Email
      if: steps.determine_action.outputs.action_type != 'skip'
      id: get_email
      run: |
        # GitHub Enterprise provides sender email in the event context
        USER_EMAIL="${{ github.event.sender.email }}"

        # Fallback for specific event types if sender.email is not available
        if [ -z "$USER_EMAIL" ]; then
          if [ "${{ github.event_name }}" = "push" ]; then
            USER_EMAIL="${{ github.event.head_commit.author.email }}"
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            USER_EMAIL="${{ github.event.pull_request.user.email }}"
          fi
        fi

        echo "User: ${{ github.actor }}"
        echo "Email: $USER_EMAIL"
        echo "user_email=$USER_EMAIL" >> $GITHUB_OUTPUT

    - name: Validate User Access
      if: steps.determine_action.outputs.action_type != 'skip'
      id: validate_user
      env:
        POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
      run: |
        # Validate user against Postman team membership
        USER="${{ github.actor }}"
        USER_EMAIL="${{ steps.get_email.outputs.user_email }}"
        ALLOW_ALL="${{ vars.POSTMAN_ALLOW_ALL_USERS || 'false' }}"

        echo "Validating user: $USER ($USER_EMAIL)"

        if [ "$ALLOW_ALL" = "true" ]; then
          echo "User validation: Allowing $USER (POSTMAN_ALLOW_ALL_USERS=true)"
          echo "user_authorized=true" >> $GITHUB_OUTPUT
        elif [ -n "$USER_EMAIL" ]; then
          echo "Checking if $USER_EMAIL is in Postman team..."
          node scripts/create-postman-resources.js validate-user "$USER_EMAIL"

          if [ $? -eq 0 ]; then
            echo "User $USER_EMAIL is authorized (found in Postman team)"
            echo "user_authorized=true" >> $GITHUB_OUTPUT
          else
            echo "User $USER_EMAIL not found in Postman team"
            echo "user_authorized=false" >> $GITHUB_OUTPUT
            echo "validation_message=User $USER ($USER_EMAIL) not found in Postman team" >> $GITHUB_OUTPUT
          fi
        else
          echo "Could not resolve email for user $USER"
          echo "user_authorized=false" >> $GITHUB_OUTPUT
          echo "validation_message=Could not resolve email for user $USER" >> $GITHUB_OUTPUT
        fi

    - name: User Authorization Warning
      if: steps.determine_action.outputs.action_type != 'skip' && steps.validate_user.outputs.user_authorized == 'false'
      run: |
        echo "## WARNING: Postman Sync Skipped"
        echo ""
        echo "${{ steps.validate_user.outputs.validation_message }}"
        echo ""
        echo "The workflow will continue without creating Postman resources."
        echo ""
        echo "To enable Postman sync:"
        echo "1. Add user to Postman team for automatic sync, or"
        echo "2. Set repository variable POSTMAN_ALLOW_ALL_USERS=true to bypass validation"

    - name: Ensure Workspace Exists
      if: steps.determine_action.outputs.action_type == 'ensure-workspace' && steps.validate_user.outputs.user_authorized == 'true'
      id: ensure_workspace
      env:
        POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
        GITHUB_OUTPUT: ${{ github.output }}
      run: |
        WORKSPACE_ID="${{ vars.POSTMAN_WORKSPACE_ID }}"

        if [ -z "$WORKSPACE_ID" ]; then
          echo "No workspace found for this repository - creating workspace + master collection"

          # Create workspace (automatically creates #main collection)
          node scripts/create-postman-resources.js workspace \
            "${{ steps.determine_action.outputs.resource_name }}"

          # Extract IDs from output
          WORKSPACE_ID=$(grep 'workspace_id=' $GITHUB_OUTPUT | tail -1 | cut -d'=' -f2)
          MASTER_COLLECTION_ID=$(grep 'master_collection_id=' $GITHUB_OUTPUT | tail -1 | cut -d'=' -f2)

          echo "Created workspace: ${{ steps.determine_action.outputs.resource_name }} ($WORKSPACE_ID)"
          echo "Created master collection: ${{ steps.determine_action.outputs.resource_name }} #main ($MASTER_COLLECTION_ID)"

          # Output for calling workflow to handle
          echo "workspace_id=$WORKSPACE_ID" >> $GITHUB_OUTPUT
          echo "master_collection_id=$MASTER_COLLECTION_ID" >> $GITHUB_OUTPUT
          echo "created_new=true" >> $GITHUB_OUTPUT

          # Check if automated storage is enabled
          if [ -n "${{ secrets.ORG_DISPATCH_TOKEN }}" ]; then
            echo "Automated variable storage is enabled - sending dispatch event"
          else
            # Manual storage instructions
            echo ""
            echo "IMPORTANT: Store these IDs as repository variables:"
            echo "  gh variable set POSTMAN_WORKSPACE_ID --body \"$WORKSPACE_ID\""
            echo "  gh variable set POSTMAN_MASTER_COLLECTION_ID --body \"$MASTER_COLLECTION_ID\""
          fi
        else
          echo "Workspace already exists: $WORKSPACE_ID"
          echo "No action needed - workspace and master collection already set up"
        fi

    - name: Auto-Create Workspace If Needed
      if: steps.determine_action.outputs.action_type == 'create-collection' && steps.validate_user.outputs.user_authorized == 'true'
      id: auto_workspace
      env:
        POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
        GITHUB_OUTPUT: ${{ github.output }}
      run: |
        WORKSPACE_ID="${{ vars.POSTMAN_WORKSPACE_ID }}"

        if [ -z "$WORKSPACE_ID" ]; then
          echo "No workspace found - auto-creating workspace for this repository"

          # Extract repo info for workspace name
          REPO="${{ github.repository }}"
          ORG_OR_USER=$(echo $REPO | cut -d'/' -f1)
          REPO_NAME=$(echo $REPO | cut -d'/' -f2)
          WORKSPACE_NAME="[${ORG_OR_USER}] ${REPO_NAME}"

          # Create workspace
          node scripts/create-postman-resources.js workspace "$WORKSPACE_NAME"

          # Extract IDs from output
          WORKSPACE_ID=$(grep 'workspace_id=' $GITHUB_OUTPUT | cut -d'=' -f2)
          MASTER_COLLECTION_ID=$(grep 'master_collection_id=' $GITHUB_OUTPUT | cut -d'=' -f2)

          echo "Auto-created workspace: $WORKSPACE_NAME ($WORKSPACE_ID)"
          echo "Auto-created master collection ID: $MASTER_COLLECTION_ID"
          echo "workspace_id=$WORKSPACE_ID" >> $GITHUB_OUTPUT
          echo "master_collection_id=$MASTER_COLLECTION_ID" >> $GITHUB_OUTPUT
          echo "created_new=true" >> $GITHUB_OUTPUT

          # Check if automated storage is enabled
          if [ -n "${{ secrets.ORG_DISPATCH_TOKEN }}" ]; then
            echo "Automated variable storage is enabled - sending dispatch event"
          else
            # Manual storage instructions
            echo ""
            echo "IMPORTANT: Store these IDs as repository variables:"
            echo "  gh variable set POSTMAN_WORKSPACE_ID --body \"$WORKSPACE_ID\""
            echo "  gh variable set POSTMAN_MASTER_COLLECTION_ID --body \"$MASTER_COLLECTION_ID\""
          fi
        else
          echo "Using existing workspace: $WORKSPACE_ID"
          echo "workspace_id=$WORKSPACE_ID" >> $GITHUB_OUTPUT
          # Also pass through master collection ID if available
          if [ -n "${{ vars.POSTMAN_MASTER_COLLECTION_ID }}" ]; then
            echo "master_collection_id=${{ vars.POSTMAN_MASTER_COLLECTION_ID }}" >> $GITHUB_OUTPUT
          fi
        fi

    - name: Create Postman Collection
      if: steps.determine_action.outputs.action_type == 'create-collection' && steps.validate_user.outputs.user_authorized == 'true'
      env:
        POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
        GITHUB_OUTPUT: ${{ github.output }}
      run: |
        # Smart collection creation - automatically forks if it's a branch
        # Pass master collection ID for efficient forking (if available)
        MASTER_COLLECTION_ID="${{ steps.auto_workspace.outputs.master_collection_id || vars.POSTMAN_MASTER_COLLECTION_ID || '' }}"

        if [ -n "$MASTER_COLLECTION_ID" ]; then
          echo "Using master collection ID for efficient forking: $MASTER_COLLECTION_ID"
          node scripts/create-postman-resources.js collection \
            "${{ steps.determine_action.outputs.resource_name }}" \
            "${{ steps.auto_workspace.outputs.workspace_id }}" \
            "$MASTER_COLLECTION_ID"
        else
          echo "No master collection ID available, will search for it"
          node scripts/create-postman-resources.js collection \
            "${{ steps.determine_action.outputs.resource_name }}" \
            "${{ steps.auto_workspace.outputs.workspace_id }}"
        fi

    - name: Merge and Cleanup Fork
      if: steps.determine_action.outputs.action_type == 'merge-cleanup' && steps.validate_user.outputs.user_authorized == 'true'
      env:
        POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
        POSTMAN_WORKSPACE_ID: ${{ vars.POSTMAN_WORKSPACE_ID }}
      run: |
        # Find and delete the fork collection after PR merge
        COLLECTION_NAME="${{ steps.determine_action.outputs.resource_name }}"

        echo "Looking for fork collection: $COLLECTION_NAME"

        # Get all collections in the workspace
        WORKSPACE_ID="${{ env.POSTMAN_WORKSPACE_ID }}"

        if [ -z "$WORKSPACE_ID" ]; then
          echo "No workspace ID found - cannot cleanup fork"
          exit 0
        fi

        # Get workspace details and find the collection
        response=$(curl -s -X GET \
          "https://api.getpostman.com/workspaces/${WORKSPACE_ID}" \
          -H "X-API-Key: ${{ env.POSTMAN_API_KEY }}")

        # Extract collection matching the fork name
        collection_id=$(echo "$response" | python3 -c "
        import sys, json
        data = json.load(sys.stdin)
        collections = data.get('workspace', {}).get('collections', [])
        fork_name = '$COLLECTION_NAME'
        for col in collections:
            if col.get('name') == fork_name:
                print(col.get('id', ''))
                break
        ")

        if [ -n "$collection_id" ]; then
          echo "Found fork collection: $collection_id"

          # Delete the fork collection
          curl -X DELETE \
            "https://api.getpostman.com/collections/${collection_id}" \
            -H "X-API-Key: ${{ env.POSTMAN_API_KEY }}"

          echo "Fork collection deleted after successful merge"
        else
          echo "Fork collection not found (may have been manually deleted)"
        fi

    - name: Automated Variable Storage (if enabled)
      if: (steps.ensure_workspace.outputs.created_new == 'true' || steps.auto_workspace.outputs.created_new == 'true')
      env:
        DISPATCH_TOKEN: ${{ secrets.ORG_DISPATCH_TOKEN }}
      run: |
        # Check if dispatch token is available
        if [ -z "$DISPATCH_TOKEN" ]; then
          echo "ORG_DISPATCH_TOKEN not configured - skipping automated storage"
          exit 0
        fi

        # Send repository dispatch event with workspace and collection IDs
        WORKSPACE_ID="${{ steps.ensure_workspace.outputs.workspace_id || steps.auto_workspace.outputs.workspace_id }}"
        MASTER_COLLECTION_ID="${{ steps.ensure_workspace.outputs.master_collection_id || steps.auto_workspace.outputs.master_collection_id }}"

        echo "Sending repository dispatch to store variables automatically..."

        response=$(curl -s -w "\n%{http_code}" -X POST \
          -H "Authorization: Bearer $DISPATCH_TOKEN" \
          -H "Accept: application/vnd.github+json" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          https://api.github.com/repos/${{ github.repository }}/dispatches \
          -d '{
            "event_type": "postman-resources-created",
            "client_payload": {
              "workspace_id": "'"$WORKSPACE_ID"'",
              "master_collection_id": "'"$MASTER_COLLECTION_ID"'"
            }
          }')

        http_code=$(echo "$response" | tail -n1)
        body=$(echo "$response" | head -n-1)

        if [ "$http_code" = "204" ]; then
          echo "✓ Repository dispatch sent successfully"
          echo "Variables will be stored automatically in the repository"
        else
          echo "Warning: Failed to send repository dispatch (HTTP $http_code)"
          echo "Response: $body"
          echo ""
          echo "Manual storage required:"
          echo "  gh variable set POSTMAN_WORKSPACE_ID --body \"$WORKSPACE_ID\""
          echo "  gh variable set POSTMAN_MASTER_COLLECTION_ID --body \"$MASTER_COLLECTION_ID\""
        fi

    - name: Create Summary
      if: steps.determine_action.outputs.action_type != 'skip'
      run: |
        echo "## Postman Sync Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Action:** ${{ steps.determine_action.outputs.action_type }}" >> $GITHUB_STEP_SUMMARY
        echo "**Resource:** ${{ steps.determine_action.outputs.resource_name }}" >> $GITHUB_STEP_SUMMARY

        if [ "${{ steps.validate_user.outputs.user_authorized }}" = "false" ]; then
          echo "**Status:** SKIPPED - User not in Postman team" >> $GITHUB_STEP_SUMMARY
        else
          echo "**Status:** SUCCESS" >> $GITHUB_STEP_SUMMARY

          if [ -n "${{ steps.ensure_workspace.outputs.workspace_id }}" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Created Resources" >> $GITHUB_STEP_SUMMARY
            echo "- Workspace ID: \`${{ steps.ensure_workspace.outputs.workspace_id }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- Master Collection ID: \`${{ steps.ensure_workspace.outputs.master_collection_id }}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Next Step:** Store these as repository variables (see workflow logs)" >> $GITHUB_STEP_SUMMARY
          fi
        fi